from app.services.capital_request_generation import resolve_capacity_enum2_id
from app.services.capital_request_generation import compute_project_dates
from app.services.capital_request_generation import Priority
from app.services.capital_request_generation import PRIORITY_TO_START_OFFSET_DAYS
from app.services.capital_request_generation import MATRIX_UNIT_TO_ID
from app.services.capital_request_generation import create_project_intent_chain
from app.models.capital.request_generation import ProjectIntentLLM
from app.models.capital.request_generation import ProjectAutoGenerated
from app.services.best_selection import call_best_selection_llm
import json
import logging
from typing import Dict, Any, List
from app.models.capital.cost_estimator import (
    ItemEstimate,
    MaterialExtractionResult,
    ScopeRequest,
    EstimationResponse,
)
from app.services.cost_estimator import CostEstimatorService, estimate_price_for_item
from fastapi import HTTPException
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import re

log = logging.getLogger("app.controllers.capital_palnning")

logger = logging.getLogger("app.controllers.capital")


class CapitalPlanningController:
    @staticmethod
    def _extract_site_name(user_command: str) -> str | None:
        """
        Heuristic extraction of proper-noun site names.
        - Matches 'site <Name>' or 'for <Name> site/location' patterns.
        - Falls back to a capitalized word/group that is not a generic placeholder.
        """
        if not user_command:
            return None
        text = user_command.strip()

        generic = {"site", "the site", "specific site", "site mentioned", "any site"}

        # Pattern 1: "... site Riyad" or "... site Witting Group"
        m = re.search(r"\bsite\s+([A-Z][A-Za-z0-9&' -]+)", text)
        if m:
            candidate = m.group(1).strip()
            if candidate.lower() not in generic:
                return candidate

        # Pattern 2: "... for Riyad site" or "... for Riyad location"
        m = re.search(r"\bfor\s+([A-Z][A-Za-z0-9&' -]+)\s+(?:site|location)\b", text)
        if m:
            candidate = m.group(1).strip()
            if candidate.lower() not in generic:
                return candidate

        # Fallback: pick a capitalized span (1-3 words) not at sentence start punctuation
        m = re.search(r"\b([A-Z][A-Za-z0-9&']+(?:\s+[A-Z][A-Za-z0-9&']+){0,2})\b", text)
        if m:
            candidate = m.group(1).strip()
            if candidate and candidate.lower() not in generic:
                return candidate
        return None
    async def estimate_materials(self, req: ScopeRequest):
        try:
            log.info("entered into capital planning controller")
            # 1) LLM: extract purchase items from SoW
            service = CostEstimatorService()
            material_result: MaterialExtractionResult = (
                await service.llm_extract_materials(req)
            )
            log.info("material_result: %s", material_result)

            if not material_result.items:
                raise HTTPException(
                    status_code=400, detail="No purchasable items found in scope."
                )

            # 2) For each item, call Tavily and estimate price
            estimates: List[ItemEstimate] = []
            for item in material_result.items:
                estimate = estimate_price_for_item(item, req)
                estimates.append(estimate)
                log.info("final estimate: %s", estimate)
            log.info("final estimates to return: %s", estimates)

            selected_estimates = []
            for estimate in estimates:
                selected = call_best_selection_llm(estimate)
                selected_estimates.append(selected)

            log.info("selected estimates to return: %s", selected_estimates)

            return {
                "ok": True,
                "data": selected_estimates,
                "error": None,
            }

        except HTTPException as e:
            raise e
        except Exception as e:
            return {
                "ok": False,
                "data": None,
                "error": {
                    "code": "SERVER_ERROR",
                    "message": str(e),
                },
            }

    def analyze_project_command(self, user_command: str) -> ProjectAutoGenerated:
        # 1) Call LLM chain â†’ strongly typed intent
        log.info("user_command: %s", user_command)
        intent: ProjectIntentLLM = create_project_intent_chain().invoke(
            {"user_command": user_command}
        )
        log.info("intent: %s", intent)

        # 2) Resolve capacity enum2 id
        enum2_id = resolve_capacity_enum2_id(
            intent.required_capacity.matrix_type,
            intent.required_capacity.unit_name,
        )

        # 3) Compute dates (use your app timezone, e.g. Asia/Karachi)
        today = datetime.now(tz=ZoneInfo("Asia/Karachi"))
        project_start, project_end = compute_project_dates(
            priority=intent.priority,
            expected_duration_days=intent.expected_project_duration_days,
            today=today,
        )

        # 4) Build final DTO
        site_name = getattr(intent, "site_name", None) or self._extract_site_name(user_command)
        return ProjectAutoGenerated(
            category=intent.category,
            required_capacity_matrix_type=intent.required_capacity.matrix_type,
            required_capacity_unit_name=intent.required_capacity.unit_name,
            required_capacity_value=float(intent.required_capacity.value),
            required_capacity_enum2_id=enum2_id,
            priority=intent.priority,
            scope_of_works=intent.scope_of_works,
            risk_level=intent.risk_level,
            impact_areas=intent.impact_areas,
            equipment_survivability_days=intent.equipment_survivability_days,
            expected_project_duration_days=intent.expected_project_duration_days,
            site_name=site_name,
            project_start=project_start,
            project_end=project_end,
        )
